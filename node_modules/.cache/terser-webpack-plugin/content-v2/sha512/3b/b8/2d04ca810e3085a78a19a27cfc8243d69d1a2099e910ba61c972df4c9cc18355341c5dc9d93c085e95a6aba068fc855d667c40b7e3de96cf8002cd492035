{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{360:function(t,a,s){\"use strict\";s.r(a);var e=s(40),n=Object(e.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"ul\",[s(\"li\",[t._v(\"所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。\")]),t._v(\" \"),s(\"li\",[t._v(\"实例生命周期也叫做：组件生命周期\")])]),t._v(\" \"),s(\"h2\",{attrs:{id:\"组件生命周期介绍\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件生命周期介绍\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 组件生命周期介绍\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[s(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"vue生命周期钩子函数\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"li\",[t._v(\"简单说：一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期\")])]),t._v(\" \"),s(\"p\",[t._v(\"生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"注意：Vue在执行过程中会\"),s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"自动调用生命周期钩子函数\")]),t._v(\"，我们只需要提供这些钩子函数即可\")],1),t._v(\" \"),s(\"li\",[t._v(\"注意：钩子函数的名称都是Vue中规定好的！\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-beforecreate\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-beforecreate\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - beforeCreate()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"说明：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用\")]),t._v(\" \"),s(\"li\",[t._v(\"注意：此时，无法获取 data中的数据、methods中的方法\")])]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"此时组件的选项还未挂载，因此无法访问methods,data,computed上的方法或数据\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-created\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-created\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - created()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据\")]),t._v(\" \"),s(\"li\",[s(\"a\",{attrs:{href:\"https://segmentfault.com/a/1190000008879966\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"vue实例生命周期 参考1\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"li\",[s(\"a\",{attrs:{href:\"https://segmentfault.com/a/1190000008010666\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"vue实例生命周期 参考2\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"li\",[t._v(\"使用场景：发送请求获取数据\")])]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。\")])]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"通常我们可以在这里对实例进行预处理。\\n也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的。\\n因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个页面发请求。\\n建议在组件路由勾子beforeRouteEnter中来完成。\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-beforemounted\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-beforemounted\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - beforeMounted()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"说明：在挂载开始之前被调用,相关的 render 函数首次被调用。\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-mounted\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-mounted\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - mounted()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"说明：此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作\")])]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"1.在这个周期内，对data的改变可以生效。但是要进下一轮的dom更新，dom上的数据才会更新。\\n2.这个周期可以获取 dom。 之前的论断有误，感谢@冯银超 和 @AnHour的提醒\\n3.beforeRouteEnter的next的勾子比mounted触发还要靠后\\n4.指令的生效在mounted周期之前\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-beforeupdated\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-beforeupdated\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - beforeUpdated()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\")]),t._v(\" \"),s(\"li\",[t._v(\"注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-updated\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-updated\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - updated()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\")])]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-beforedestroy\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-beforedestroy\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - beforeDestroy()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"说明：实例销毁之前调用。在这一步，实例仍然完全可用。\")]),t._v(\" \"),s(\"li\",[t._v(\"使用场景：实例销毁之前，执行清理任务，比如：清除定时器等\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"钩子函数-destroyed\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#钩子函数-destroyed\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 钩子函数 - destroyed()\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"组件生命周期总结\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件生命周期总结\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 组件生命周期总结\")]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"beforecreated\")]),t._v(\"：el 和 data 并未初始化\\n\"),s(\"br\"),t._v(\" \"),s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"created\")]),t._v(\"：完成了 data 数据的初始化，el没有\\n\"),s(\"br\"),t._v(\" \"),s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"beforeMount\")]),t._v(\"：完成了 el 和 data 初始化\\n\"),s(\"br\"),t._v(\" \"),s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"mounted\")]),t._v(\" ：完成挂载\")],1),t._v(\" \"),s(\"p\",[t._v(\"另外在 \"),s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"beforeMount\")]),t._v(\" 阶段，我们能发现el还是 { { xxx } }，\\n\"),s(\"br\"),t._v(\"\\n这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。\\n\"),s(\"br\"),t._v(\"\\n到后面\"),s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"mounted\")]),t._v(\"挂载的时候再把值渲染进去。\")],1)]),t._v(\" \"),s(\"h2\",{attrs:{id:\"全局路由钩子\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#全局路由钩子\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 全局路由钩子\")]),t._v(\" \"),s(\"p\",[t._v(\"作用于所有路由切换，一般在main.js里面定义\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"router-beforeeach\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#router-beforeeach\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" \"),s(\"strong\",[t._v(\"router.beforeEach\")])]),t._v(\" \"),s(\"div\",{staticClass:\"language-js line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[s(\"code\",[t._v(\"示例\\nrouter\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"beforeEach\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"to\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"from\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" next\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"'路由全局勾子：beforeEach -- 有next方法'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"next\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"5\")]),s(\"br\")])]),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"一般在这个勾子的回调中，对路由进行拦截。\\n比如，未登录的用户，直接进入了需要登录才可见的页面，那么可以用next(false)来拦截，使其跳回原页面。\\n值得注意的是，如果没有调用next方法，那么页面将卡在那。\")])]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[s(\"font\",{attrs:{color:\"#0086b3\"}},[t._v(\"next\")]),t._v(\"的四种用法\")],1),t._v(\" \"),s(\"ol\",[s(\"li\",[s(\"font\",{attrs:{color:\"#0086b3\"}},[t._v(\"next\")]),t._v(\"() 跳入下一个页面\")],1),t._v(\" \"),s(\"li\",[s(\"font\",{attrs:{color:\"#0086b3\"}},[t._v(\"next\")]),t._v(\"(\"),s(\"font\",{attrs:{color:\"#c7254e\"}},[t._v(\"'/path'\")]),t._v(\") 改变路由的跳转方向，使其跳到另一个路由\")],1),t._v(\" \"),s(\"li\",[s(\"font\",{attrs:{color:\"#0086b3\"}},[t._v(\"next\")]),t._v(\"(false)  返回原来的页面\")],1),t._v(\" \"),s(\"li\",[s(\"font\",{attrs:{color:\"#0086b3\"}},[t._v(\"next\")]),t._v(\"((vm)=>{})  仅在beforeRouteEnter中可用，vm是组件实例。\")],1)])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"router-aftereach\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#router-aftereach\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" \"),s(\"strong\",[t._v(\"router.afterEach\")])]),t._v(\" \"),s(\"div\",{staticClass:\"language-js line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//示例\")]),t._v(\"\\nrouter\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"afterEach\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"to\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"from\")])]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"'路由全局勾子：afterEach --- 没有next方法'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\")])]),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"在所有路由跳转结束的时候调用，和beforeEach是类似的，但是它没有next方法\")])]),t._v(\" \"),s(\"h2\",{attrs:{id:\"组件路由勾子\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件路由勾子\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 组件路由勾子\")]),t._v(\" \"),s(\"p\",[t._v(\"和全局勾子不同的是，它仅仅作用于某个组件，一般在.vue文件中去定义。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"beforerouteenter\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#beforerouteenter\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" \"),s(\"strong\",[t._v(\"beforeRouteEnter\")])]),t._v(\" \"),s(\"div\",{staticClass:\"language-js line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//示例\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"beforeRouteEnter\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"to\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"from\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" next\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"this\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//undefined，不能用this来获取vue实例\")]),t._v(\"\\n    console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"'组件路由勾子：beforeRouteEnter'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"next\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"vm\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n      console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"vm\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//vm为vue的实例\")]),t._v(\"\\n      console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"'组件路由勾子beforeRouteEnter的next'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"5\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"6\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"7\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"8\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"9\")]),s(\"br\")])]),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"这个是一个很不同的勾子。因为beforeRouterEnter在组件创建之前调用，所以它无法直接用this来访问组件实例。\")]),t._v(\" \"),s(\"p\",[t._v(\"为了弥补这一点，vue-router开发人员，给他的next方法加了特技，可以传一个回调，回调的第一个参数即是组件实例。\")]),t._v(\" \"),s(\"p\",[t._v(\"一般我们可以利用这点，对实例上的数据进行修改，调用实例上的方法。\")]),t._v(\" \"),s(\"p\",[t._v(\"我们可以在这个方法去请求数据，在数据获取到之后，再调用next就能保证你进页面的时候，数据已经获取到了。\")]),t._v(\" \"),s(\"p\",[t._v(\"没错，这里next有阻塞的效果。你没调用的话，就会一直卡在那\")])]),t._v(\" \"),s(\"div\",{staticClass:\"warning custom-block\"},[s(\"p\",[t._v(\"next(vm=>{console.log('next')  })\\n这个里面的代码是很晚执行的，在组件mounted周期之后。没错，这是一个坑。你要注意。\")]),t._v(\" \"),s(\"p\",[t._v(\"beforeRouteEnter的代码时很早执行的，在组件beforeCreate之前；\")]),t._v(\" \"),s(\"p\",[t._v(\"但是next里面回调的执行，很晚，在mounted之后，可以说是目前我找到的，离dom渲染最近的一个周期。\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"beforerouteleave\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#beforerouteleave\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" beforeRouteLeave\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-js line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"beforeRouteLeave\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"to\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"from\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" next\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"this\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"    \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//可以访问vue实例\")]),t._v(\"\\n    console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"'组件路由勾子：beforeRouteLeave'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"next\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"5\")]),s(\"br\")])]),s(\"p\",[t._v(\"在离开路由时调用。可以用this来访问组件实例。但是next中不能传回调。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"beforerouteupdate\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#beforerouteupdate\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" beforeRouteUpdate\")]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"这个方法是vue-router2.2版本加上的。因为原来的版本中，如果一个在两个子路由之间跳转，是不触发beforeRouteLeave的。这会导致某些重置操作，没地方触发。在之前，我们都是用watch $route来hack的。但是通过这个勾子，我们有了更好的方式。\")])]),t._v(\" \"),s(\"p\",[t._v(\"老实讲，我没用过这个勾子，所以各位可以查看一下文章之前的文档，去尝试一下，再和我交流交流。\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"指令周期\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#指令周期\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 指令周期\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"绑定自定义指令的时候也会有对应的周期。\")]),t._v(\" \"),s(\"li\",[t._v(\"这几个周期，我比较常用的，一般是只有bind。\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"bind\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bind\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" bind\")]),t._v(\" \"),s(\"p\",[t._v(\"只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"inserted\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#inserted\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" inserted\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。\")]),t._v(\" \"),s(\"li\",[t._v(\"实际上是插入vnode的时候调用。\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"update\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#update\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" update\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"被绑定元素所在的模板更新时调用，而不论绑定值是否变化。\")]),t._v(\" \"),s(\"li\",[t._v(\"通过比较更新前后的绑定值，可以忽略不必要的模板更新。\")])]),t._v(\" \"),s(\"div\",{staticClass:\"danger custom-block\"},[s(\"p\",[t._v(\"慎用，如果在指令里绑定事件，并且用这个周期的，记得把事件注销\")])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"componentupdated\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#componentupdated\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" componentUpdated\")]),t._v(\" \"),s(\"p\",[t._v(\"被绑定元素所在模板完成一次更新周期时调用。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"unbind\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#unbind\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" unbind\")]),t._v(\" \"),s(\"p\",[t._v(\"只调用一次， 指令与元素解绑时调用。\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"vue-nexttick、vm-nexttick\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-nexttick、vm-nexttick\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Vue.nextTick、vm.$nextTick\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-js line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//示例：\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"created\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"this\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"$nextTick\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n      console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"'nextTick'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//回调里的函数一直到真实的dom渲染结束后，才执行\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n    console\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"'组件：created'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"5\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"6\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"7\")]),s(\"br\")])]),s(\"blockquote\",[s(\"p\",[s(\"strong\",[t._v(\"nextTick方法的回调会在dom更新后再执行，因此可以和一些dom操作搭配一起用，如 ref。\\n非常好用，可以解决很多疑难杂症。\")])])]),t._v(\" \"),s(\"div\",{staticClass:\"tip custom-block\"},[s(\"p\",[t._v(\"场景：\\n你用ref获得一个输入框，用v-model绑定。\\n在某个方法里改变绑定的值，在这个方法里用ref去获取dom并取值，你会发现dom的值并没有改变。\\n因为此时vue的方法，还没去触发dom的改变。\\n因此你可以把获取dom值的操作放在vm.$nextTick的回调里，就可以了。\")])])])},[],!1,null,null,null);a.default=n.exports}}]);","extractedComments":[]}